<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pink Particle Heart Tree</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            /* Nền màu tối ánh tím hồng huyền ảo */
            background: radial-gradient(ellipse at bottom, #2c001e 0%, #09000a 100%);
            font-family: 'Brush Script MT', 'Lucida Handwriting', cursive, sans-serif;
            height: 100vh;
            user-select: none;
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            cursor: grab;
        }
        canvas:active { cursor: grabbing; }

        #message-container {
            position: absolute;
            bottom: 8%;
            width: 100%;
            text-align: center;
            z-index: 10;
            pointer-events: none;
        }

        h1 {
            font-size: 3.5rem;
            color: #fff0f5; 
            text-shadow: 0 0 10px #ff69b4, 0 0 20px #ff1493;
            opacity: 0;
            transition: opacity 3s ease-in-out;
        }
        h1.show { opacity: 1; }
    </style>
</head>
<body>
    <div id="message-container">
        <h1 id="merry-text">Merry Christmas</h1>
    </div>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        // Sử dụng alpha: false để tối ưu hiệu suất nếu nền không trong suốt
        const ctx = canvas.getContext('2d', { alpha: false }); 
        const messageElement = document.getElementById('merry-text');

        let w, h;
        const particles = [];
        const snowParticles = [];
        
        // CẤU HÌNH SỐ LƯỢNG HẠT
        const treeParticleCount = 3500; 
        const heartParticleCount = 600; // Số hạt tạo nên trái tim
        const snowCount = 200;

        const config = {
            treeWidth: 350,
            treeHeight: 650,
            layers: 9,
            spinSpeed: 0.005,
            fallChance: 0.002,
            groundLevel: 350
        };

        // --- BẢNG MÀU TÔNG HỒNG ---
        const treeColors = [
            {r:255,g:182,b:193}, {r:255,g:105,b:180}, 
            {r:255,g:240,b:245}, {r:219,g:112,b:147}
        ];
        const ornamentColors = [
            {r:255,g:20,b:147}, {r:255,g:255,b:255}, 
            {r:238,g:130,b:238}, {r:183,g:110,b:121}
        ];
        // Màu riêng cho trái tim (sáng hơn, rực hơn)
        const heartColors = [
            {r:255,g:255,b:255}, // White
            {r:255,g:20,b:147},  // Deep Pink
            {r:255,g:105,b:180}  // Hot Pink
        ];

        let revealY = 0;
        let isHeartActive = false;
        let heartTransition = 0;
        let isMessageShown = false;

        // --- CAMERA / MOUSE VARIABLES ---
        let currentRotationOffset = 0; let currentTiltOffset = 0; let zoomScale = 1.0;          
        let targetRotation = 0; let targetTilt = 0; let targetZoom = 1.0;
        let isDragging = false; let startX = 0; let startY = 0; let lastRotation = 0; let lastTilt = 0;

        // --- XỬ LÝ ĐIỀU KHIỂN ---
        function handleStart(x, y) {
            isDragging = true; startX = x; startY = y;
            lastRotation = targetRotation; lastTilt = targetTilt;
        }
        function handleMove(x, y) {
            if (isDragging) {
                targetRotation = lastRotation + (x - startX) / 200;
                let newTilt = lastTilt + (y - startY) / 200;
                targetTilt = Math.max(-0.5, Math.min(0.5, newTilt));
            }
        }
        canvas.addEventListener('mousedown', e => handleStart(e.clientX, e.clientY));
        window.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
        window.addEventListener('mouseup', () => { isDragging = false; });
        canvas.addEventListener('touchstart', e => handleStart(e.touches[0].clientX, e.touches[0].clientY), {passive: false});
        canvas.addEventListener('touchmove', e => { e.preventDefault(); handleMove(e.touches[0].clientX, e.touches[0].clientY); }, {passive: false});
        canvas.addEventListener('touchend', () => { isDragging = false; });
        canvas.addEventListener('wheel', e => { 
            e.preventDefault(); targetZoom += e.deltaY * -0.001; 
            targetZoom = Math.min(Math.max(0.5, targetZoom), 2.5); 
        }, { passive: false });

        function resize() {
            w = canvas.width = window.innerWidth; h = canvas.height = window.innerHeight;
            config.treeHeight = h * 0.85; config.treeWidth = Math.min(w, h) * 0.52;
            config.groundLevel = (config.treeHeight / 2) + 20;
            revealY = config.treeHeight / 2 + 150;
            isHeartActive = false; heartTransition = 0;
            isMessageShown = false; messageElement.classList.remove('show');
        }
        window.addEventListener('resize', resize);
        function lerp(start, end, t) { return start * (1 - t) + end * t; }

        // --- LỚP TUYẾT RƠI ---
        class SnowFlake {
            constructor() { this.reset(true); }
            reset(initial = false) {
                const treeTop = -config.treeHeight/2 - 150;
                const treeBottom = config.treeHeight/2 + 100;
                this.y = initial ? treeTop + Math.random()*(treeBottom-treeTop) : treeTop;
                this.radius = Math.random() * w * 0.8; // Phân bố rộng hơn
                this.angle = Math.random()*Math.PI*2;
                this.speedY = 0.5 + Math.random()*1.5;
                this.size = 1 + Math.random()*2;
                this.opacity = 0.2 + Math.random()*0.6;
            }
            update() {
                this.y += this.speedY;
                if (this.y > config.treeHeight/2 + 100) this.reset();
            }
            draw(ctx, cx, cy, rotY, rotX) {
                let lx = Math.cos(this.angle + rotY) * this.radius;
                let lz = Math.sin(this.angle + rotY) * this.radius;
                let ly = this.y;
                let yFinal = ly * Math.cos(rotX) - lz * Math.sin(rotX);
                let zFinal = ly * Math.sin(rotX) + lz * Math.cos(rotX);
                const scale = (350 / (350 + zFinal + 450)) * zoomScale;
                if (scale < 0) return;
                const x = cx + lx * scale; const y = cy + yFinal * scale;
                ctx.beginPath(); ctx.arc(x, y, this.size * scale, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 240, 245, ${this.opacity * Math.min(1, scale)})`; 
                ctx.fill();
            }
        }
        function initSnow() { snowParticles.length = 0; for(let i=0; i<snowCount; i++) snowParticles.push(new SnowFlake()); }

        // --- LỚP HẠT TỔNG HỢP (CÂY + TRÁI TIM) ---
        class Particle {
            constructor(type) { 
                this.type = type; // 'tree', 'ornament', hoặc 'heart'
                this.reset(true); 
            }
            reset(initial = false) {
                this.alpha = 0;
                this.twinkleSpeed = 0.05 + Math.random() * 0.1;
                this.twinkleOffset = Math.random() * Math.PI * 2;
                this.isFalling = false; this.isGrounded = false; this.groundLife = 300;

                if (this.type === 'heart') {
                    // --- TẠO HÌNH TRÁI TIM 3D ---
                    const t = Math.random() * Math.PI * 2;
                    // Công thức hình trái tim 2D
                    let hx = 16 * Math.pow(Math.sin(t), 3);
                    let hy = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                    
                    // Scale và lấp đầy
                    const scale = 3.0;
                    const fill = Math.sqrt(Math.random()); // Phân bố đều hơn
                    hx *= scale * fill;
                    hy *= scale * fill;
                    // Tạo độ dày (Z) cho trái tim
                    let hz = (Math.random() - 0.5) * 30 * fill;

                    // Vị trí ở đỉnh cây
                    this.lx = hx;
                    this.ly = -config.treeHeight / 2 - 50 + hy;
                    this.lz = hz;
                    
                    this.color = heartColors[Math.floor(Math.random()*heartColors.length)];
                    this.size = Math.random()*3 + 2;
                    this.targetAlpha = 1.0;
                    this.fadeSpeed = 0.02; // Hiện nhanh hơn

                } else {
                    // --- TẠO HÌNH CÂY THÔNG ---
                    const layerProgress = Math.random();
                    let progressInLayer = this.type === 'ornament' ? 0.7 + Math.random()*0.3 : (layerProgress * config.layers) % 1;
                    let baseR = config.treeWidth * layerProgress * 0.5;
                    let layerR = baseR * (0.3 + 2.0 * progressInLayer);
                    this.angle = Math.random() * Math.PI * 2;
                    this.lx = Math.cos(this.angle) * layerR; 
                    this.lz = Math.sin(this.angle) * layerR;
                    this.ly = (layerProgress - 0.5) * config.treeHeight;

                    if (this.type === 'ornament') {
                        this.color = ornamentColors[Math.floor(Math.random()*ornamentColors.length)];
                        this.size = Math.random()*3 + 4; this.targetAlpha = 1.0;
                    } else {
                        this.color = treeColors[Math.floor(Math.random()*treeColors.length)];
                        this.size = Math.random()*2 + 1; this.targetAlpha = Math.random()*0.6 + 0.4;
                    }
                    this.fadeSpeed = 0.003 + Math.random()*0.005;
                    this.fallSpeed = 2 + Math.random()*2;
                }
            }

            update(time) {
                // Logic hiển thị khác nhau cho hạt cây và hạt trái tim
                let canShow = false;
                if (this.type === 'heart') {
                    // Hạt trái tim hiện ra dựa trên biến heartTransition
                    if (heartTransition > 0) {
                        this.alpha = Math.min(this.targetAlpha, this.alpha + this.fadeSpeed);
                         // Liên kết độ mờ tổng thể với tiến trình xuất hiện trái tim
                        this.alpha *= heartTransition;
                        canShow = true;
                    }
                } else {
                    // Hạt cây hiện ra theo revealY (cây mọc lên)
                    const currentAngle = this.angle + time * config.spinSpeed;
                    const spiralOffset = Math.sin(currentAngle * 60);
                    const triggerPoint = revealY + spiralOffset;
                    if (this.ly > triggerPoint) {
                        if (this.alpha < this.targetAlpha && !this.isGrounded) this.alpha += this.fadeSpeed;
                        canShow = true;
                    }
                }

                // Logic nhấp nháy (Twinkle)
                if (!this.isFalling && !this.isGrounded && canShow) {
                    const twinkle = Math.sin(time * this.twinkleSpeed + this.twinkleOffset);
                    if (this.type === 'heart' || this.type === 'ornament') {
                        // Trái tim và quả châu nhấp nháy mạnh và sáng hơn
                        this.actualAlpha = this.alpha * (0.7 + twinkle * 0.3);
                    } else {
                        this.actualAlpha = this.alpha * (0.8 + twinkle * 0.2);
                    }
                } else {
                    this.actualAlpha = this.alpha;
                }

                // Logic rơi rụng (chỉ cho hạt cây)
                if (this.type !== 'heart') {
                    if (this.isFalling) {
                        this.ly += this.fallSpeed;
                        this.lx += Math.sin(time * 0.1) * 0.5; 
                        if (this.ly >= config.groundLevel) {
                            this.ly = config.groundLevel; this.isFalling = false; this.isGrounded = true;
                            this.lx += (Math.random()-0.5)*10; this.lz += (Math.random()-0.5)*10;
                        }
                    } else if (this.isGrounded) {
                        this.groundLife--;
                        if (this.groundLife < 50) this.alpha -= 0.02;
                        if (this.groundLife < 0 || this.alpha <= 0) this.reset();
                    } else if (canShow && this.alpha > 0.4 && Math.random() < config.fallChance) {
                        this.isFalling = true;
                    }
                }
            }

            draw(ctx, cx, cy, rotY, rotX) {
                if (this.actualAlpha <= 0.01) return;

                // Tính toán vị trí 3D sau khi xoay
                let tempX = this.lx * Math.cos(rotY) - this.lz * Math.sin(rotY);
                let tempZ = this.lx * Math.sin(rotY) + this.lz * Math.cos(rotY);
                let tempY = this.ly;
                
                // Xoay thêm một chút cho trái tim để nó sinh động
                if (this.type === 'heart') {
                    const heartRot = Math.sin(time * 0.03) * 0.2;
                    let tx = tempX; tempX = tx * Math.cos(heartRot) - tempY * Math.sin(heartRot);
                    tempY = tx * Math.sin(heartRot) + tempY * Math.cos(heartRot);
                }

                let finalY = tempY * Math.cos(rotX) - tempZ * Math.sin(rotX);
                let finalZ = tempY * Math.sin(rotX) + tempZ * Math.cos(rotX);
                
                const scale = (350 / (350 + finalZ + 450)) * zoomScale;
                if (scale < 0) return;
                
                const x2d = cx + tempX * scale; const y2d = cy + finalY * scale; let size = this.size * scale;
                
                // Vẽ hạt
                ctx.beginPath(); 
                ctx.arc(x2d, y2d, size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.actualAlpha})`; 
                
                // Thêm glow nhẹ cho trái tim và quả châu (nếu máy mạnh có thể bật shadowBlur)
                // ctx.shadowBlur = (this.type === 'heart' ? 10 : 0) * scale;
                // ctx.shadowColor = "white";
                ctx.fill();
                // ctx.shadowBlur = 0;

                // Điểm sáng trắng cho hạt to
                if (this.type !== 'tree' && size > 3) {
                     ctx.beginPath();
                     ctx.fillStyle = `rgba(255, 255, 255, ${this.actualAlpha * 0.8})`;
                     ctx.arc(x2d - size*0.2, y2d - size*0.2, size*0.3, 0, Math.PI * 2);
                     ctx.fill();
                }
            }
        }

        // --- KHỞI TẠO HẠT ---
        function initParticles() {
            particles.length = 0;
            for (let i = 0; i < treeParticleCount; i++) {
                particles.push(new Particle(Math.random() < 0.02 ? 'ornament' : 'tree'));
            }
            for (let i = 0; i < heartParticleCount; i++) {
                particles.push(new Particle('heart'));
            }
        }

        let time = 0;
        function animate() {
            time++;
            // Logic mọc cây và hiện trái tim
            const treeTop = -config.treeHeight / 2;
            if (revealY > treeTop - 50) revealY -= 2.5;
            if (revealY <= treeTop + 50) isHeartActive = true;
            if (isHeartActive && heartTransition < 1) { 
                heartTransition += 0.008; 
                if (heartTransition >= 1 && !isMessageShown) { 
                    messageElement.classList.add('show'); isMessageShown = true; 
                }
            }

            // Làm mượt điều khiển
            currentRotationOffset += (targetRotation - currentRotationOffset) * 0.1;
            currentTiltOffset += (targetTilt - currentTiltOffset) * 0.1;
            zoomScale += (targetZoom - zoomScale) * 0.1;

            // Xóa màn hình và vẽ nền gradient
            const gradient = ctx.createRadialGradient(w/2, h, 0, w/2, h, h);
            gradient.addColorStop(0, '#2c001e'); gradient.addColorStop(1, '#09000a');
            ctx.fillStyle = gradient; ctx.fillRect(0, 0, w, h);

            const cx = w / 2; const cy = h / 2;
            const rotY = (time * config.spinSpeed) + currentRotationOffset;
            const rotX = currentTiltOffset;

            // Sử dụng 'lighter' để tạo hiệu ứng phát sáng lấp lánh khi các hạt chồng lên nhau
            ctx.globalCompositeOperation = 'lighter'; 
            snowParticles.forEach(snow => { snow.update(); snow.draw(ctx, cx, cy, rotY, rotX); });
            // Sắp xếp hạt theo chiều sâu (Z) để vẽ đúng thứ tự (hạt xa vẽ trước)
            particles.sort((a, b) => b.lz - a.lz);
            particles.forEach(p => { p.update(time); p.draw(ctx, cx, cy, rotY, rotX); });
            ctx.globalCompositeOperation = 'source-over';
            
            requestAnimationFrame(animate);
        }

        resize();
        initSnow();
        initParticles();
        animate();
    </script>
</body>
</html>