<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Heart Tree</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(ellipse at bottom, #2c001e 0%, #09000a 100%);
            font-family: 'Brush Script MT', 'Lucida Handwriting', cursive, sans-serif;
            height: 100vh;
            user-select: none;
            touch-action: none; /* Ngăn chặn hành vi cuộn/zoom mặc định của trình duyệt */
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        #message-container {
            position: absolute;
            bottom: 10%;
            width: 100%;
            text-align: center;
            z-index: 10;
            pointer-events: none;
        }
        h1 {
            font-size: 3rem; /* Giảm font một chút cho mobile */
            color: #fff0f5; 
            text-shadow: 0 0 10px #ff69b4, 0 0 20px #ff1493;
            opacity: 0;
            transition: opacity 3s ease-in-out;
            margin: 0;
            padding: 0 10px;
        }
        h1.show { opacity: 1; }
    </style>
</head>
<body>
    <div id="message-container">
        <h1 id="merry-text">Merry Christmas</h1>
    </div>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { alpha: false }); 
        const messageElement = document.getElementById('merry-text');

        let w, h;
        const particles = [];
        const snowParticles = [];
        
        // --- CẤU HÌNH ---
        // Giảm nhẹ số lượng hạt để điện thoại chạy mượt hơn mà không nóng máy
        const isMobile = window.innerWidth < 768;
        const treeParticleCount = isMobile ? 2500 : 3500; 
        const heartParticleCount = isMobile ? 400 : 600; 
        const snowCount = isMobile ? 100 : 200;

        const config = {
            treeWidth: isMobile ? 280 : 350,
            treeHeight: isMobile ? 500 : 650,
            layers: 9,
            spinSpeed: 0.005,
            fallChance: 0.002,
            groundLevel: isMobile ? 300 : 350
        };

        const treeColors = [
            {r:255,g:182,b:193}, {r:255,g:105,b:180}, 
            {r:255,g:240,b:245}, {r:219,g:112,b:147}
        ];
        const ornamentColors = [
            {r:255,g:20,b:147}, {r:255,g:255,b:255}, 
            {r:238,g:130,b:238}, {r:183,g:110,b:121}
        ];
        const heartColors = [
            {r:255,g:255,b:255}, {r:255,g:20,b:147}, {r:255,g:105,b:180}
        ];

        let revealY = 0;
        let isHeartActive = false;
        let heartTransition = 0;
        let isMessageShown = false;

        // --- CAMERA / MOUSE VARIABLES ---
        let currentRotationOffset = 0; let currentTiltOffset = 0; let zoomScale = 1.0;          
        let targetRotation = 0; let targetTilt = 0; let targetZoom = 1.0;
        let isDragging = false; let startX = 0; let startY = 0; let lastRotation = 0; let lastTilt = 0;

        // --- XỬ LÝ ĐIỀU KHIỂN ---
        function handleStart(x, y) {
            isDragging = true; startX = x; startY = y;
            lastRotation = targetRotation; lastTilt = targetTilt;
        }
        function handleMove(x, y) {
            if (isDragging) {
                targetRotation = lastRotation + (x - startX) / 200;
                let newTilt = lastTilt + (y - startY) / 200;
                targetTilt = Math.max(-0.5, Math.min(0.5, newTilt));
            }
        }
        
        canvas.addEventListener('mousedown', e => handleStart(e.clientX, e.clientY));
        window.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
        window.addEventListener('mouseup', () => { isDragging = false; });
        
        canvas.addEventListener('touchstart', e => handleStart(e.touches[0].clientX, e.touches[0].clientY), {passive: false});
        canvas.addEventListener('touchmove', e => { 
            e.preventDefault(); // Quan trọng: Ngăn kéo trang web trên điện thoại
            handleMove(e.touches[0].clientX, e.touches[0].clientY); 
        }, {passive: false});
        canvas.addEventListener('touchend', () => { isDragging = false; });
        
        canvas.addEventListener('wheel', e => { 
            e.preventDefault(); targetZoom += e.deltaY * -0.001; 
            targetZoom = Math.min(Math.max(0.5, targetZoom), 2.5); 
        }, { passive: false });

        // --- HÀM RESIZE ĐÃ ĐƯỢC SỬA LỖI VỠ HÌNH ---
        function resize() {
            // Lấy tỉ lệ điểm ảnh của thiết bị (thường là 2 hoặc 3 trên điện thoại)
            // Giới hạn max là 2 để tối ưu hiệu năng (3x thường quá nặng mà mắt thường khó phân biệt)
            const dpr = Math.min(window.devicePixelRatio || 1, 2);
            
            // Kích thước logic (CSS pixels)
            w = window.innerWidth;
            h = window.innerHeight;

            // Kích thước vật lý (Physical pixels)
            canvas.width = w * dpr;
            canvas.height = h * dpr;

            // Đặt kích thước hiển thị CSS
            canvas.style.width = w + 'px';
            canvas.style.height = h + 'px';

            // Scale context để mọi nét vẽ tự động to lên theo DPR
            ctx.scale(dpr, dpr);

            // Cập nhật lại cấu hình cây cho phù hợp màn hình
            config.treeHeight = h * (isMobile ? 0.75 : 0.85); 
            config.treeWidth = Math.min(w, h) * (isMobile ? 0.6 : 0.52);
            config.groundLevel = (config.treeHeight / 2) + 20;
            revealY = config.treeHeight / 2 + 150;
            
            isHeartActive = false; heartTransition = 0;
            isMessageShown = false; messageElement.classList.remove('show');
        }
        window.addEventListener('resize', resize);

        class SnowFlake {
            constructor() { this.reset(true); }
            reset(initial = false) {
                const treeTop = -config.treeHeight/2 - 150;
                const treeBottom = config.treeHeight/2 + 100;
                this.y = initial ? treeTop + Math.random()*(treeBottom-treeTop) : treeTop;
                this.radius = Math.random() * w * 0.8;
                this.angle = Math.random()*Math.PI*2;
                this.speedY = 0.5 + Math.random()*1.5;
                this.size = 1 + Math.random()*2;
                this.opacity = 0.2 + Math.random()*0.6;
            }
            update() {
                this.y += this.speedY;
                if (this.y > config.treeHeight/2 + 100) this.reset();
            }
            draw(ctx, cx, cy, rotY, rotX) {
                let lx = Math.cos(this.angle + rotY) * this.radius;
                let lz = Math.sin(this.angle + rotY) * this.radius;
                let ly = this.y;
                let yFinal = ly * Math.cos(rotX) - lz * Math.sin(rotX);
                let zFinal = ly * Math.sin(rotX) + lz * Math.cos(rotX);
                const scale = (350 / (350 + zFinal + 450)) * zoomScale;
                if (scale < 0) return;
                const x = cx + lx * scale; const y = cy + yFinal * scale;
                ctx.beginPath(); ctx.arc(x, y, this.size * scale, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 240, 245, ${this.opacity * Math.min(1, scale)})`; 
                ctx.fill();
            }
        }
        function initSnow() { snowParticles.length = 0; for(let i=0; i<snowCount; i++) snowParticles.push(new SnowFlake()); }

        class Particle {
            constructor(type) { 
                this.type = type; 
                this.reset(true); 
            }
            reset(initial = false) {
                this.alpha = 0;
                this.twinkleSpeed = 0.05 + Math.random() * 0.1;
                this.twinkleOffset = Math.random() * Math.PI * 2;
                this.isFalling = false; this.isGrounded = false; this.groundLife = 300;

                if (this.type === 'heart') {
                    const t = Math.random() * Math.PI * 2;
                    let hx = 16 * Math.pow(Math.sin(t), 3);
                    let hy = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                    const scale = isMobile ? 2.5 : 3.0; // Tim nhỏ hơn xíu trên mobile
                    const fill = Math.sqrt(Math.random());
                    hx *= scale * fill;
                    hy *= scale * fill;
                    let hz = (Math.random() - 0.5) * 30 * fill;

                    this.lx = hx;
                    this.ly = -config.treeHeight / 2 - 50 + hy;
                    this.lz = hz;
                    
                    this.color = heartColors[Math.floor(Math.random()*heartColors.length)];
                    this.size = Math.random()*3 + 2;
                    this.targetAlpha = 1.0;
                    this.fadeSpeed = 0.02;

                } else {
                    const layerProgress = Math.random();
                    let progressInLayer = this.type === 'ornament' ? 0.7 + Math.random()*0.3 : (layerProgress * config.layers) % 1;
                    let baseR = config.treeWidth * layerProgress * 0.5;
                    let layerR = baseR * (0.3 + 2.0 * progressInLayer);
                    this.angle = Math.random() * Math.PI * 2;
                    this.lx = Math.cos(this.angle) * layerR; 
                    this.lz = Math.sin(this.angle) * layerR;
                    this.ly = (layerProgress - 0.5) * config.treeHeight;

                    if (this.type === 'ornament') {
                        this.color = ornamentColors[Math.floor(Math.random()*ornamentColors.length)];
                        this.size = Math.random()*3 + 4; this.targetAlpha = 1.0;
                    } else {
                        this.color = treeColors[Math.floor(Math.random()*treeColors.length)];
                        this.size = Math.random()*2 + 1; this.targetAlpha = Math.random()*0.6 + 0.4;
                    }
                    this.fadeSpeed = 0.003 + Math.random()*0.005;
                    this.fallSpeed = 2 + Math.random()*2;
                }
            }

            update(time) {
                let canShow = false;
                if (this.type === 'heart') {
                    if (heartTransition > 0) {
                        this.alpha = Math.min(this.targetAlpha, this.alpha + this.fadeSpeed);
                        this.alpha *= heartTransition;
                        canShow = true;
                    }
                } else {
                    const currentAngle = this.angle + time * config.spinSpeed;
                    const spiralOffset = Math.sin(currentAngle * 60);
                    const triggerPoint = revealY + spiralOffset;
                    if (this.ly > triggerPoint) {
                        if (this.alpha < this.targetAlpha && !this.isGrounded) this.alpha += this.fadeSpeed;
                        canShow = true;
                    }
                }

                if (!this.isFalling && !this.isGrounded && canShow) {
                    const twinkle = Math.sin(time * this.twinkleSpeed + this.twinkleOffset);
                    if (this.type === 'heart' || this.type === 'ornament') {
                        this.actualAlpha = this.alpha * (0.7 + twinkle * 0.3);
                    } else {
                        this.actualAlpha = this.alpha * (0.8 + twinkle * 0.2);
                    }
                } else {
                    this.actualAlpha = this.alpha;
                }

                if (this.type !== 'heart') {
                    if (this.isFalling) {
                        this.ly += this.fallSpeed;
                        this.lx += Math.sin(time * 0.1) * 0.5; 
                        if (this.ly >= config.groundLevel) {
                            this.ly = config.groundLevel; this.isFalling = false; this.isGrounded = true;
                            this.lx += (Math.random()-0.5)*10; this.lz += (Math.random()-0.5)*10;
                        }
                    } else if (this.isGrounded) {
                        this.groundLife--;
                        if (this.groundLife < 50) this.alpha -= 0.02;
                        if (this.groundLife < 0 || this.alpha <= 0) this.reset();
                    } else if (canShow && this.alpha > 0.4 && Math.random() < config.fallChance) {
                        this.isFalling = true;
                    }
                }
            }

            draw(ctx, cx, cy, rotY, rotX) {
                if (this.actualAlpha <= 0.01) return;

                let tempX = this.lx * Math.cos(rotY) - this.lz * Math.sin(rotY);
                let tempZ = this.lx * Math.sin(rotY) + this.lz * Math.cos(rotY);
                let tempY = this.ly;
                
                if (this.type === 'heart') {
                    const heartRot = Math.sin(time * 0.03) * 0.2;
                    let tx = tempX; tempX = tx * Math.cos(heartRot) - tempY * Math.sin(heartRot);
                    tempY = tx * Math.sin(heartRot) + tempY * Math.cos(heartRot);
                }

                let finalY = tempY * Math.cos(rotX) - tempZ * Math.sin(rotX);
                let finalZ = tempY * Math.sin(rotX) + tempZ * Math.cos(rotX);
                
                const scale = (350 / (350 + finalZ + 450)) * zoomScale;
                if (scale < 0) return;
                
                const x2d = cx + tempX * scale; const y2d = cy + finalY * scale; let size = this.size * scale;
                
                ctx.beginPath(); 
                ctx.arc(x2d, y2d, size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${this.color.r}, ${this.color.g}, ${this.color.b}, ${this.actualAlpha})`; 
                ctx.fill();

                if (this.type !== 'tree' && size > 3) {
                     ctx.beginPath();
                     ctx.fillStyle = `rgba(255, 255, 255, ${this.actualAlpha * 0.8})`;
                     ctx.arc(x2d - size*0.2, y2d - size*0.2, size*0.3, 0, Math.PI * 2);
                     ctx.fill();
                }
            }
        }

        function initParticles() {
            particles.length = 0;
            for (let i = 0; i < treeParticleCount; i++) {
                particles.push(new Particle(Math.random() < 0.02 ? 'ornament' : 'tree'));
            }
            for (let i = 0; i < heartParticleCount; i++) {
                particles.push(new Particle('heart'));
            }
        }

        let time = 0;
        function animate() {
            time++;
            const treeTop = -config.treeHeight / 2;
            if (revealY > treeTop - 50) revealY -= 2.5;
            if (revealY <= treeTop + 50) isHeartActive = true;
            if (isHeartActive && heartTransition < 1) { 
                heartTransition += 0.008; 
                if (heartTransition >= 1 && !isMessageShown) { 
                    messageElement.classList.add('show'); isMessageShown = true; 
                }
            }

            currentRotationOffset += (targetRotation - currentRotationOffset) * 0.1;
            currentTiltOffset += (targetTilt - currentTiltOffset) * 0.1;
            zoomScale += (targetZoom - zoomScale) * 0.1;

            const gradient = ctx.createRadialGradient(w/2, h, 0, w/2, h, h);
            gradient.addColorStop(0, '#2c001e'); gradient.addColorStop(1, '#09000a');
            ctx.fillStyle = gradient; 
            // Dùng w, h đã scale trong hàm resize thì không cần nhân tỉ lệ ở đây nữa
            // Tuy nhiên vì ta scale context, nên tọa độ vẽ là tọa độ logic (CSS pixel)
            // Cần fillRect theo kích thước logic
            ctx.fillRect(0, 0, w, h);

            const cx = w / 2; const cy = h / 2;
            const rotY = (time * config.spinSpeed) + currentRotationOffset;
            const rotX = currentTiltOffset;

            ctx.globalCompositeOperation = 'lighter'; 
            snowParticles.forEach(snow => { snow.update(); snow.draw(ctx, cx, cy, rotY, rotX); });
            particles.sort((a, b) => b.lz - a.lz);
            particles.forEach(p => { p.update(time); p.draw(ctx, cx, cy, rotY, rotX); });
            ctx.globalCompositeOperation = 'source-over';
            
            requestAnimationFrame(animate);
        }

        // Gọi khởi tạo lần đầu
        resize();
        initSnow();
        initParticles();
        animate();
    </script>
</body>
</html>